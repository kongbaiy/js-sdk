<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>WebRTC å±å¹•å½•åˆ¶æ–¹æ¡ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }

        .section {
            margin: 25px 0;
            padding: 20px;
            border: 1px solid #eaeaea;
            border-radius: 8px;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            margin: 5px;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #4f46e5;
            color: white;
        }

        .btn-danger {
            background: #dc2626;
            color: white;
        }

        .btn-success {
            background: #059669;
            color: white;
        }

        button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        video {
            width: 100%;
            border-radius: 8px;
            background: #000;
            margin: 10px 0;
        }

        .status {
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
            display: none;
        }

        .recording {
            background: #fee2e2;
            color: #dc2626;
            display: block;
        }

        .preview {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 768px) {
            .preview {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ğŸ¥ WebRTC å±å¹•å½•åˆ¶æ–¹æ¡ˆ</h1>

        <div class="section">
            <h2>1. é€‰æ‹©å½•åˆ¶æº</h2>
            <div class="controls">
                <button class="btn-primary" onclick="startRecording('screen')">ğŸ–¥ï¸ å½•åˆ¶æ•´ä¸ªå±å¹•</button>
                <button class="btn-primary" onclick="startRecording('window')">ğŸ“ å½•åˆ¶åº”ç”¨çª—å£</button>
                <button class="btn-primary" onclick="startRecording('tab')">ğŸŒ å½•åˆ¶æµè§ˆå™¨æ ‡ç­¾é¡µ</button>
                <button class="btn-danger" onclick="stopRecording()" id="stopBtn" disabled>â¹ï¸ åœæ­¢å½•åˆ¶</button>
            </div>

            <div id="status" class="status recording">
                <span id="statusText">ç­‰å¾…å¼€å§‹å½•åˆ¶...</span>
                <span id="timer" style="float:right;">00:00</span>
            </div>

            <div class="info">
                <p><strong>âš ï¸ æ³¨æ„ï¼š</strong>æµè§ˆå™¨å°†å¼¹å‡ºé€‰æ‹©çª—å£ï¼Œè¯·é€‰æ‹©è¦å½•åˆ¶çš„å±å¹•/çª—å£ã€‚æŸäº›å—ä¿æŠ¤å†…å®¹ï¼ˆå¦‚Netflixï¼‰å¯èƒ½æ— æ³•å½•åˆ¶ã€‚</p>
            </div>
        </div>

        <div class="section">
            <h2>2. å®æ—¶é¢„è§ˆä¸å½•åˆ¶</h2>
            <div class="preview">
                <div>
                    <h3>ğŸ”´ å®æ—¶é¢„è§ˆ</h3>
                    <video id="previewVideo" autoplay muted playsinline></video>
                    <p>æ­¤é¢„è§ˆä»…ç”¨äºç¡®è®¤å½•åˆ¶å†…å®¹</p>
                </div>
                <div>
                    <h3>ğŸ“¼ å½•åˆ¶å›æ”¾</h3>
                    <video id="playbackVideo" controls></video>
                    <div style="margin-top: 10px;">
                        <button class="btn-success" onclick="downloadRecording()" id="downloadBtn" disabled>ğŸ’¾
                            ä¸‹è½½å½•åˆ¶æ–‡ä»¶</button>
                        <button onclick="playRecording()" id="playBtn" disabled>â–¶ï¸ æ’­æ”¾å½•åˆ¶</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>3. å½•åˆ¶è®¾ç½®</h2>
            <div class="settings">
                <div style="margin: 10px 0;">
                    <label>
                        <input type="checkbox" id="recordAudio" checked>
                        å½•åˆ¶ç³»ç»ŸéŸ³é¢‘ï¼ˆéœ€è¦Chrome 74+ï¼‰
                    </label>
                </div>
                <div style="margin: 10px 0;">
                    <label>
                        <input type="checkbox" id="showCursor" checked>
                        æ˜¾ç¤ºé¼ æ ‡æŒ‡é’ˆ
                    </label>
                </div>
                <div style="margin: 10px 0;">
                    <label>è§†é¢‘è´¨é‡ï¼š
                        <select id="videoQuality">
                            <option value="high">é«˜è´¨é‡ï¼ˆæ–‡ä»¶è¾ƒå¤§ï¼‰</option>
                            <option value="medium" selected>ä¸­ç­‰è´¨é‡</option>
                            <option value="low">ä½è´¨é‡ï¼ˆèŠ‚çœç©ºé—´ï¼‰</option>
                        </select>
                    </label>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
 * WebRTC å±å¹•å½•åˆ¶å™¨
 * æ”¯æŒï¼šå±å¹•/çª—å£/æ ‡ç­¾é¡µå½•åˆ¶ + ç³»ç»ŸéŸ³é¢‘
 */
        class WebRTCRecorder {
            constructor(options = {}) {
                this.config = {
                    mimeType: 'video/webm;codecs=vp9,opus',
                    audioBitsPerSecond: 128000,
                    videoBitsPerSecond: 2500000,
                    frameRate: 30,
                    ...options
                };

                // çŠ¶æ€ç®¡ç†
                this.stream = null;
                this.mediaRecorder = null;
                this.recordedChunks = [];
                this.isRecording = false;
                this.startTime = null;
                this.timerInterval = null;

                // è§†é¢‘è´¨é‡æ˜ å°„
                this.qualityMap = {
                    low: { width: 1280, height: 720, bitrate: 1000000 },
                    medium: { width: 1920, height: 1080, bitrate: 2500000 },
                    high: { width: 2560, height: 1440, bitrate: 5000000 }
                };

                console.log('ğŸ¥ WebRTCå½•å±å™¨åˆå§‹åŒ–å®Œæˆ');
            }

            /**
             * å¼€å§‹å±å¹•å½•åˆ¶
             * @param {string} sourceType - 'screen' | 'window' | 'tab'
             */
            async startRecording(sourceType = 'screen') {
                try {
                    // 1. è¯·æ±‚å±å¹•å…±äº«æƒé™
                    this.updateStatus('ğŸ”„ è¯·æ±‚å±å¹•å…±äº«æƒé™...');

                    const constraints = this.getConstraints(sourceType);
                    this.stream = await navigator.mediaDevices.getDisplayMedia(constraints);

                    // 2. è®¾ç½®åœæ­¢å½•åˆ¶ç›‘å¬ï¼ˆç”¨æˆ·ç‚¹å‡»æµè§ˆå™¨åœæ­¢æŒ‰é’®ï¼‰
                    this.stream.getVideoTracks()[0].onended = () => {
                        console.log('ç”¨æˆ·é€šè¿‡æµè§ˆå™¨åœæ­¢äº†å…±äº«');
                        this.stopRecording();
                    };

                    // 3. æ˜¾ç¤ºé¢„è§ˆ
                    this.showPreview(this.stream);

                    // 4. å¼€å§‹å½•åˆ¶
                    this.startMediaRecorder();

                    // 5. å¯åŠ¨è®¡æ—¶å™¨
                    this.startTimer();

                    this.updateStatus('ğŸ”´ æ­£åœ¨å½•åˆ¶ä¸­...', true);
                    this.setControlStates(true);

                    console.log('âœ… å½•åˆ¶å¼€å§‹');
                    return true;

                } catch (error) {
                    this.handleError(error);
                    return false;
                }
            }

            /**
             * è·å–åª’ä½“çº¦æŸ
             */
            getConstraints(sourceType) {
                const quality = this.qualityMap[
                    document.getElementById('videoQuality').value || 'medium'
                ];

                const constraints = {
                    video: {
                        cursor: document.getElementById('showCursor').checked ? 'always' : 'never',
                        frameRate: { ideal: this.config.frameRate },
                        width: { ideal: quality.width },
                        height: { ideal: quality.height }
                    },
                    audio: document.getElementById('recordAudio').checked
                };

                // æŒ‡å®šæ¥æºç±»å‹ï¼ˆéæ‰€æœ‰æµè§ˆå™¨æ”¯æŒï¼‰
                if (sourceType && constraints.video) {
                    constraints.video.displaySurface = sourceType;
                }

                return constraints;
            }

            /**
             * å¯åŠ¨ MediaRecorder
             */
            startMediaRecorder() {
                // é€‰æ‹©æœ€ä½³çš„ MIME ç±»å‹
                const mimeType = this.getSupportedMimeType();

                const options = {
                    mimeType: mimeType,
                    audioBitsPerSecond: this.config.audioBitsPerSecond,
                    videoBitsPerSecond: this.config.videoBitsPerSecond
                };

                // åˆ›å»º MediaRecorder å®ä¾‹
                this.mediaRecorder = new MediaRecorder(this.stream, options);
                this.recordedChunks = [];

                // æ•°æ®å¯ç”¨æ—¶è§¦å‘
                this.mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        this.recordedChunks.push(event.data);
                        console.log(`ğŸ“¦ æ”¶åˆ°æ•°æ®å—: ${event.data.size} bytes`);
                    }
                };

                // å½•åˆ¶åœæ­¢æ—¶è§¦å‘
                this.mediaRecorder.onstop = () => {
                    this.onRecordingStopped();
                };

                // å¼€å§‹å½•åˆ¶ï¼Œæ¯1ç§’æ”¶é›†ä¸€æ¬¡æ•°æ®
                this.mediaRecorder.start(1000);
                this.isRecording = true;
            }

            /**
             * è·å–æµè§ˆå™¨æ”¯æŒçš„ MIME ç±»å‹
             */
            getSupportedMimeType() {
                const types = [
                    'video/webm;codecs=vp9,opus',
                    'video/webm;codecs=vp8,opus',
                    'video/webm;codecs=h264,opus',
                    'video/mp4;codecs=h264,aac',
                    'video/webm',
                    'video/mp4'
                ];

                for (const type of types) {
                    if (MediaRecorder.isTypeSupported(type)) {
                        console.log(`âœ… æ”¯æŒ MIME ç±»å‹: ${type}`);
                        return type;
                    }
                }

                console.warn('âš ï¸ æ— æ”¯æŒçš„ MIME ç±»å‹ï¼Œä½¿ç”¨é»˜è®¤');
                return '';
            }

            /**
             * åœæ­¢å½•åˆ¶
             */
            async stopRecording() {
                if (!this.isRecording || !this.mediaRecorder) {
                    return null;
                }

                this.updateStatus('â³ æ­£åœ¨åœæ­¢å½•åˆ¶å¹¶å¤„ç†æ•°æ®...');

                // åœæ­¢ MediaRecorder
                this.mediaRecorder.stop();

                // åœæ­¢æ‰€æœ‰è½¨é“
                this.stream.getTracks().forEach(track => track.stop());

                // æ¸…é™¤è®¡æ—¶å™¨
                this.stopTimer();

                this.isRecording = false;
                this.setControlStates(false);

                // ç­‰å¾… onstop äº‹ä»¶å®Œæˆ
                await new Promise(resolve => setTimeout(resolve, 500));

                return this.getRecordingData();
            }

            /**
             * å½•åˆ¶åœæ­¢åçš„å¤„ç†
             */
            onRecordingStopped() {
                console.log('â¹ï¸ MediaRecorder å·²åœæ­¢');

                if (this.recordedChunks.length === 0) {
                    console.warn('âš ï¸ æ²¡æœ‰å½•åˆ¶åˆ°ä»»ä½•æ•°æ®');
                    this.updateStatus('âŒ å½•åˆ¶å¤±è´¥ï¼šæ²¡æœ‰æ•°æ®');
                    return;
                }

                const recordingData = this.getRecordingData();

                // æ˜¾ç¤ºå›æ”¾
                this.showPlayback(recordingData.blob);

                // å¯ç”¨ä¸‹è½½æŒ‰é’®
                document.getElementById('downloadBtn').disabled = false;
                document.getElementById('playBtn').disabled = false;

                const duration = (Date.now() - this.startTime) / 1000;
                this.updateStatus(`âœ… å½•åˆ¶å®Œæˆï¼æ—¶é•¿: ${duration.toFixed(1)}ç§’ï¼Œå¤§å°: ${(recordingData.size / 1024 / 1024).toFixed(2)}MB`);
            }

            /**
             * è·å–å½•åˆ¶æ•°æ®
             */
            getRecordingData() {
                const blob = new Blob(this.recordedChunks, {
                    type: this.mediaRecorder.mimeType
                });

                return {
                    blob: blob,
                    url: URL.createObjectURL(blob),
                    size: blob.size,
                    duration: Date.now() - this.startTime,
                    mimeType: this.mediaRecorder.mimeType,
                    chunks: this.recordedChunks.length
                };
            }

            /**
             * æ˜¾ç¤ºå®æ—¶é¢„è§ˆ
             */
            showPreview(stream) {
                const previewVideo = document.getElementById('previewVideo');
                previewVideo.srcObject = stream;
                previewVideo.muted = true;

                previewVideo.onloadedmetadata = () => {
                    previewVideo.play().catch(e => console.warn('é¢„è§ˆæ’­æ”¾å¤±è´¥:', e));
                };
            }

            /**
             * æ˜¾ç¤ºå½•åˆ¶å›æ”¾
             */
            showPlayback(blob) {
                const playbackVideo = document.getElementById('playbackVideo');
                const url = URL.createObjectURL(blob);

                playbackVideo.src = url;
                playbackVideo.controls = true;

                playbackVideo.onloadeddata = () => {
                    console.log('ğŸ¬ å›æ”¾è§†é¢‘å·²åŠ è½½');
                    playbackVideo.play().catch(e => console.warn('å›æ”¾å¤±è´¥:', e));
                };
            }

            /**
             * ä¸‹è½½å½•åˆ¶æ–‡ä»¶
             */
            downloadRecording() {
                const recordingData = this.getRecordingData();
                if (!recordingData.blob || recordingData.size === 0) {
                    alert('æ²¡æœ‰å¯ä¸‹è½½çš„å½•åˆ¶æ–‡ä»¶');
                    return;
                }

                // æ ¹æ® MIME ç±»å‹ç¡®å®šæ‰©å±•å
                const extension = recordingData.mimeType.includes('mp4') ? 'mp4' : 'webm';
                const filename = `recording-${new Date().toISOString().slice(0, 19).replace(/[:]/g, '-')}.${extension}`;

                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const a = document.createElement('a');
                a.href = recordingData.url;
                a.download = filename;
                a.style.display = 'none';

                document.body.appendChild(a);
                a.click();

                // æ¸…ç†
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(recordingData.url);
                }, 100);

                console.log(`ğŸ’¾ æ–‡ä»¶å·²ä¸‹è½½: ${filename}`);
            }

            /**
             * è®¡æ—¶å™¨ç›¸å…³
             */
            startTimer() {
                this.startTime = Date.now();
                this.timerInterval = setInterval(() => {
                    const elapsed = Date.now() - this.startTime;
                    const minutes = Math.floor(elapsed / 60000);
                    const seconds = Math.floor((elapsed % 60000) / 1000);
                    document.getElementById('timer').textContent =
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }, 1000);
            }

            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }

            /**
             * æ›´æ–°çŠ¶æ€æ˜¾ç¤º
             */
            updateStatus(message, isRecording = false) {
                const statusEl = document.getElementById('status');
                const statusText = document.getElementById('statusText');

                statusText.textContent = message;

                if (isRecording) {
                    statusEl.style.display = 'block';
                    statusEl.className = 'status recording';
                } else if (message) {
                    statusEl.style.display = 'block';
                    statusEl.className = 'status';
                } else {
                    statusEl.style.display = 'none';
                }
            }

            /**
             * è®¾ç½®æ§ä»¶çŠ¶æ€
             */
            setControlStates(isRecording) {
                document.getElementById('stopBtn').disabled = !isRecording;
            }

            /**
             * é”™è¯¯å¤„ç†
             */
            handleError(error) {
                console.error('å½•åˆ¶é”™è¯¯:', error);

                let message = 'å½•åˆ¶å¤±è´¥: ';

                switch (error.name) {
                    case 'NotAllowedError':
                        message += 'ç”¨æˆ·æ‹’ç»äº†æƒé™è¯·æ±‚';
                        break;
                    case 'NotFoundError':
                        message += 'æœªæ‰¾åˆ°å¯å½•åˆ¶çš„å±å¹•/çª—å£';
                        break;
                    case 'NotReadableError':
                        message += 'æ— æ³•è®¿é—®å±å¹•/çª—å£ï¼Œå¯èƒ½è¢«å…¶ä»–åº”ç”¨å ç”¨';
                        break;
                    case 'OverconstrainedError':
                        message += 'æ— æ³•æ»¡è¶³å½•åˆ¶è¦æ±‚ï¼Œè¯·é™ä½è´¨é‡è®¾ç½®';
                        break;
                    default:
                        message += error.message || 'æœªçŸ¥é”™è¯¯';
                }

                this.updateStatus(`âŒ ${message}`);
                alert(message);
            }

            /**
             * æ£€æŸ¥æµè§ˆå™¨æ”¯æŒæƒ…å†µ
             */
            static isSupported() {
                return !!(navigator.mediaDevices &&
                    navigator.mediaDevices.getDisplayMedia &&
                    window.MediaRecorder);
            }

            /**
             * è·å–æµè§ˆå™¨æ”¯æŒè¯¦æƒ…
             */
            static getSupportDetails() {
                const details = {
                    getDisplayMedia: !!(navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia),
                    MediaRecorder: !!window.MediaRecorder,
                    mimeTypes: []
                };

                // æµ‹è¯•æ”¯æŒçš„ MIME ç±»å‹
                const testTypes = [
                    'video/webm;codecs=vp9,opus',
                    'video/webm;codecs=vp8,opus',
                    'video/webm;codecs=h264,opus',
                    'video/mp4;codecs=h264,aac'
                ];

                details.mimeTypes = testTypes.filter(type =>
                    MediaRecorder.isTypeSupported(type)
                );

                return details;
            }
        }

        // å…¨å±€å½•å±å™¨å®ä¾‹
let recorder = null;

// é¡µé¢åŠ è½½å®Œæˆ
window.addEventListener('DOMContentLoaded', () => {
    // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
    if (!WebRTCRecorder.isSupported()) {
        document.getElementById('statusText').textContent = 
            'âŒ æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ WebRTC å±å¹•å½•åˆ¶';
        document.querySelectorAll('button').forEach(btn => {
            btn.disabled = true;
        });
        return;
    }
    
    // æ˜¾ç¤ºæ”¯æŒä¿¡æ¯
    const supportDetails = WebRTCRecorder.getSupportDetails();
    console.log('æµè§ˆå™¨æ”¯æŒè¯¦æƒ…:', supportDetails);
    
    // åˆå§‹åŒ–å½•å±å™¨
    recorder = new WebRTCRecorder();
    
    console.log('âœ… é¡µé¢åˆå§‹åŒ–å®Œæˆ');
});

/**
 * å¼€å§‹å½•åˆ¶
 */
async function startRecording(sourceType) {
    if (!recorder) return;
    
    // é‡ç½®çŠ¶æ€
    document.getElementById('playbackVideo').src = '';
    document.getElementById('downloadBtn').disabled = true;
    document.getElementById('playBtn').disabled = true;
    
    // å¼€å§‹å½•åˆ¶
    const success = await recorder.startRecording(sourceType);
    
    if (success) {
        console.log(`å¼€å§‹å½•åˆ¶: ${sourceType}`);
    }
}

/**
 * åœæ­¢å½•åˆ¶
 */
async function stopRecording() {
    if (!recorder) return;
    
    await recorder.stopRecording();
}

/**
 * æ’­æ”¾å½•åˆ¶å†…å®¹
 */
function playRecording() {
    const playbackVideo = document.getElementById('playbackVideo');
    if (playbackVideo.src) {
        playbackVideo.currentTime = 0;
        playbackVideo.play().catch(e => console.warn('æ’­æ”¾å¤±è´¥:', e));
    }
}

/**
 * ä¸‹è½½å½•åˆ¶æ–‡ä»¶
 */
function downloadRecording() {
    if (!recorder) return;
    
    recorder.downloadRecording();
}

/**
 * å½•åˆ¶æ•´ä¸ªå±å¹•
 */
function recordFullScreen() {
    startRecording('screen');
}

/**
 * å½•åˆ¶åº”ç”¨çª—å£
 */
function recordApplicationWindow() {
    startRecording('window');
}

/**
 * å½•åˆ¶æµè§ˆå™¨æ ‡ç­¾é¡µ
 */
function recordBrowserTab() {
    startRecording('tab');
}

// ç»‘å®šå…¨å±€å‡½æ•°
window.startRecording = startRecording;
window.stopRecording = stopRecording;
window.playRecording = playRecording;
window.downloadRecording = downloadRecording;
window.recordFullScreen = recordFullScreen;
window.recordApplicationWindow = recordApplicationWindow;
window.recordBrowserTab = recordBrowserTab;
    </script>
</body>

</html>