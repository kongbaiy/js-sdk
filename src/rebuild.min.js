(function (window, document) {
    'use strict';

    const TAG_NAME_REGEX = /<\/?\s*([a-zA-Z][a-zA-Z0-9-]*)\b/;  // 获取开始或结束标签的名
    const SINGLE_TAG_REGEX = /<([^\s>]+)/;  // 单标签
    const TAG_REGEX = /<\/?[a-z]+[^>]*>|[^<>]+/gi;  // 开始和结束标签
    const $FOR_REGEX = /r-for\s*=\s*"([^"]+)"/;  //$for 属性值
    const $IF_REGEX = /r-if\s*=\s*"([^"]+)"/;  //$if 属性值
    const $ATTRS_REGEX = /\sr-[a-z]\w+\s*=\s*"[^"]*"/g;  // 所有$符号的属性
    const $CONTENT_REGEX = /\{\{(.+?)\}\}/g;  // $符号内容
    const RELATIONAL_SYMBOLS_REGEX = /<=|>=|\=+|>|</;  // 关系符号
    const STR_REGEX = /^("|'|`)(.*)\1$/;
    const CALLBACK_REGEX = /\s*setContent\((.*?)\)\s*/g;
    const FUN_NAME_REGEX = /([a-zA-Z_$][a-zA-Z0-9_$]*)/;

    function useId() {
        return Math.random().toString(36).substring(2, 15)
    }

    function hasSingleTag(tag) {
        return ['img', 'br', 'input'].includes(tag.match(SINGLE_TAG_REGEX)?.[1]);
    }

    function findStartTag(currentIndex, tags) {
        let index = 1;
        let prevTag = tags[currentIndex - index];
        const currentTag = tags[currentIndex];
        const currentTagName = currentTag.tag?.match(TAG_NAME_REGEX)?.[1];
        let prevTagName;

        while (currentTagName !== prevTagName) {
            prevTag = tags[currentIndex - index] || prevTag;
            prevTagName = prevTag.tag?.match(TAG_NAME_REGEX)?.[1];
            index++;
        }

        return prevTag
    }

    function resolver(htmlStr) {
        const tags = [];
        let match;
        let index = 0;
        let annotation = false;

        htmlStr = htmlStr.replace('<!--', '<annotation>').replace('-->', '</annotation>');

        while ((match = TAG_REGEX.exec(htmlStr)) !== null) {
            const tag = match[0].trim();

            if (!tag) continue;

            if (tag.startsWith('</')) {
                const item = {
                    type: 'node',
                    tag,
                };

                if (annotation) item.$disabledFor = true;
                if (item.tag.includes('</annotation>')) annotation = false;

                tags.push(item);

                const prevTag = findStartTag(index, tags);
                prevTag.endIndex = index;

            } else if (tag.startsWith('<')) {
                const forMatch = tag.match($FOR_REGEX)?.[1];
                const ifMatch = tag.match($IF_REGEX)?.[1];
                const item = {
                    type: 'node',
                    tag: tag.replace($ATTRS_REGEX, ''),
                };

                if (forMatch) item.$for = forMatch;
                if (ifMatch) item.$if = ifMatch.replace('&gt;', '>').replace('&lt;', '<');
                if (item.tag.includes('<annotation>')) annotation = true;
                if (annotation) item.$disabledFor = true;

                tags.push(item);

            } else {
                tags.push({
                    type: 'content',
                    content: tag,
                });
            }

            index++;
        }

        return tags;
    }

    function callbackParse(content = '') {
        return content.replace(CALLBACK_REGEX, (_match, args) => {
            const newArgs = args.split(',').map(arg => {
                if (STR_REGEX.test(arg.trim())) return arg
                return 'this.' + arg.trim()
            });
            const funName = content.match(FUN_NAME_REGEX)[0];
            
            return `${funName}(${newArgs})`
        });
    }

    function contentParse(content = '') {
        return content.replace($CONTENT_REGEX, (_match, key) => {
            const newKey = callbackParse(key);
            return '${this.' + newKey + '}'
        });
    }

    function parseIf(ifContent) {
        ifContent = ifContent.replace(/^\s*if\s*=\s*/, '');

        const operator = ifContent.match(RELATIONAL_SYMBOLS_REGEX);
        const [left, right] = ifContent.split(RELATIONAL_SYMBOLS_REGEX);
        let leftVariable = (STR_REGEX.test(left.trim()) || /\d/.test(left.trim())) ? left.trim() : `this.${left.trim()}`;
        let rightVariable = (STR_REGEX.test(right.trim()) || /\d/.test(right.trim())) ? right.trim() : `this.${right.trim()}`;

        let code = '';
        code += `if(`;
        code += `${leftVariable}`;
        code += `${operator}`;
        code += `${rightVariable}`;
        code += `) {\n`;

        return code;
    }

    function parseFor(forContent) {
        const expressionFor = forContent.split(/\s(in)\s/);
        const iterable = expressionFor[expressionFor.length - 1];
        const expressionLeft = expressionFor[0].split(',');
        const itemKey = expressionLeft[0];
        const indexKey = expressionLeft[1];
        let code = '';

        code += `for (this['${itemKey}'] of this.${iterable} || []) {\n`;

        if (indexKey) code += `this.${indexKey} = this.${iterable}.indexOf(this.${itemKey});\n`;

        return code
    }

    function compose(tags) {
        let code = '';

        for (let t of tags) {
            const { type, tag, content } = t;

            if (type === 'node') {
                if (t.$if) {
                    code += parseIf(t.$if);
                    tags[t.endIndex].isIf = true;
                }

                if (t.$for && !t.$disabledFor) {
                    code += parseFor(t.$for);
                    if (hasSingleTag(t.tag)) t.isFor = true
                    else tags[t.endIndex].isFor = true;
                }

                code += `html += '${tag}';\n`;

                if (t.isFor) code += '}\n';
                if (t.isIf) code += '}\n';

            } else {
                code += 'html +=`' + contentParse(content) + '`;\n';
            }
        }

        return code;
    }

    // 解析模板
    // 1. 解析标签
    // 2. 替换内容
    // 3. 返回渲染结果
    // 4. 处理循环和条件
    // 5. 返回最终的HTML字符串
    // 6. 支持嵌套标签
    // 7. 支持条件渲染
    // 8. 支持循环渲染
    // 9. 支持数据绑定
    function render(html, context = {}) {
        if (!Reflect.ownKeys(context).length) return ''

        const tags = resolver(html);
        const code = compose(tags, context)
            .replaceAll('<annotation>', '<!--')
            .replaceAll('</annotation>', '-->');

        const renderedContent = new Function(
            `
                let html = ''\n;
                ${code}
                return html;\n
            `
        );

        return renderedContent.call(context);
    }

    function replaceElementWithPlaceholder(el, placeholderText = 'PLACEHOLDER') {
        const comment = document.createComment(placeholderText);
        el.replaceWith(comment);
        return comment; // 可以用于恢复
    }

    function rebuild(selector, context) {
        const element = document.querySelector(selector);
        const outerHTML = element.outerHTML;

        element.setAttribute('hidden', true);

        const id = useId();
        replaceElementWithPlaceholder(element, id);
        
        const newHtml = render(outerHTML, context);

        document.body.innerHTML = document.body.innerHTML.replace(`<!--${id}-->`, newHtml);
        element.setAttribute('hidden', false);
    }

    window.s = {
        rebuild
    };
})(window, document);